# Express.js Middleware

## 🧠 What is Middleware?

Middleware functions in Express are functions that have access to the **request object (`req`)**, the **response object (`res`)**, and the **next middleware function (`next`)** in the application’s request-response cycle.

```js
(req, res, next) => { /* your logic here */ }





It is like a mid-layer which is used to verify the reuest which was generated by client, if it is correct it passes information to server and server reponds to the client request directly. if it is not correct, the middleware itself responds to the client with error message.





They can:

Execute code

Modify the req and res objects

End the request-response cycle

Call next() to pass control to the next middleware








📚 Types of Middleware :---


1. Application-level Middleware
Used across the whole app using app.use() or route-specific.


app.use((req, res, next) => {
  console.log('Time:', Date.now());
  next();
});

app.get('/user', (req, res) => {
  res.send('User route');
});





2. Router-level Middleware
Works with instances of express.Router().


const router = express.Router();

router.use((req, res, next) => {
  console.log('Router middleware');
  next();
});

router.get('/profile', (req, res) => {
  res.send('User profile');
});

app.use('/user', router);






3. Built-in Middleware
Express provides middleware like:

express.static() — for serving static files

express.json() — parses incoming JSON requests

express.urlencoded() — parses URL-encoded bodies


app.use(express.static('public'));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));





4. Third-party Middleware
Installed via npm.

Examples:

morgan — HTTP request logger

cors — Cross-Origin Resource Sharing

body-parser (mostly legacy, now part of Express)


npm install morgan cors


const morgan = require('morgan');
const cors = require('cors');

app.use(morgan('dev'));
app.use(cors());





5. Error-handling Middleware
Handles errors in the app.


app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});





🧩 Order of Middleware Execution
Middleware executes in the order they are defined in the code.


app.use(mw1);
app.use('/route', mw2);
app.get('/route', mw3);

This order matters — the earlier it’s declared, the sooner it runs.





🛑 Ending the Cycle
A middleware can end the request without calling next():


app.use((req, res, next) => {
  res.send('Request stopped here.');
});


Or call next() to continue:


app.use((req, res, next) => {
  console.log('Continuing...');
  next();
});





✅ Real-World Example: Auth Middleware


function verifyUser(req, res, next) {
  if (req.headers.authorization === 'secret-token') {
    next(); // authenticated
  } else {
    res.status(401).send('Unauthorized');
  }
}

app.get('/dashboard', verifyUser, (req, res) => {
  res.send('Welcome to dashboard');
});





🧪 Custom Middleware
You can create reusable custom middleware modules:


// logger.js
function logger(req, res, next) {
  console.log(`${req.method} ${req.url}`);
  next();
}
module.exports = logger;

// in app.js
const logger = require('./logger');
app.use(logger);





🔁 Middleware Chain Flow Diagram


Client Request
     ⬇
[ Middleware 1 ]
     ⬇ next()
[ Middleware 2 ]
     ⬇ next()
[ Route Handler ]
     ⬇
[ Response Sent ]





📌 Summary

| Middleware Type   | Purpose                              |
| ----------------- | ------------------------------------ |
| Application-level | Used globally or for specific routes |
| Router-level      | Bound to an `express.Router()`       |
| Built-in          | JSON/body parsing, static files      |
| Third-party       | Logging, CORS, etc.                  |
| Error-handling    | Catch and handle errors              |
```
